<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<title>Portfolio Monitor Assistant</title>
		<style>
			:root {
				color-scheme: dark;
				font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
				background: #05070c;
				color: #f2f6ff;
			}
			body {
				margin: 0;
				min-height: 100vh;
				background: radial-gradient(circle at top left, #18243a, #05070c);
			}
			header {
				padding: 2.5rem 1.5rem 1rem;
				text-align: center;
			}
			header h1 {
				margin: 0;
				font-size: clamp(2rem, 3vw, 3.2rem);
				letter-spacing: 0.12em;
			}
			header p {
				margin: 0.5rem 0 0.75rem;
				opacity: 0.75;
			}
			nav {
				display: flex;
				justify-content: center;
				gap: 1rem;
				margin-bottom: 0.5rem;
				flex-wrap: wrap;
			}
			nav a {
				color: rgba(255, 255, 255, 0.8);
				text-decoration: none;
				font-weight: 600;
				padding: 0.4rem 0.9rem;
				border-radius: 999px;
				border: 1px solid transparent;
			}
			nav a[aria-current="page"] {
				border-color: rgba(255, 255, 255, 0.3);
				background: rgba(255, 255, 255, 0.08);
				color: #fff;
			}
			main {
				max-width: 1000px;
				margin: 0 auto;
				padding: 0 1.5rem 4rem;
				display: grid;
				gap: 1.5rem;
			}
			section {
				background: rgba(6, 10, 18, 0.85);
				border: 1px solid rgba(255, 255, 255, 0.08);
				border-radius: 18px;
				padding: 1.5rem;
				backdrop-filter: blur(12px);
				box-shadow: 0 18px 40px rgba(3, 7, 18, 0.4);
			}
			table {
				width: 100%;
				border-collapse: collapse;
			}
			th,
			td {
				padding: 0.75rem 0.5rem;
				border-bottom: 1px solid rgba(255, 255, 255, 0.06);
				text-align: left;
				word-break: break-word;
			}
			th {
				font-size: 0.75rem;
				text-transform: uppercase;
				letter-spacing: 0.08em;
				color: rgba(186, 198, 223, 0.8);
			}
			td.status-ok {
				color: #6ee7a6;
			}
			td.status-error {
				color: #f08c8c;
			}
			#chat-section {
				display: grid;
				gap: 1rem;
			}
			#chat-log {
				border: 1px solid rgba(255, 255, 255, 0.06);
				border-radius: 14px;
				padding: 1rem;
				max-height: 360px;
				overflow-y: auto;
				display: flex;
				flex-direction: column;
				gap: 1rem;
				background: rgba(8, 12, 22, 0.9);
			}
			.chat-entry {
				display: flex;
				flex-direction: column;
				gap: 0.4rem;
			}
			.chat-bubble {
				max-width: 80%;
				padding: 0.75rem 1rem;
				border-radius: 12px;
				white-space: pre-wrap;
				line-height: 1.5;
				box-shadow: 0 12px 24px rgba(0, 0, 0, 0.2);
			}
			.chat-entry[data-role="assistant"] .chat-bubble {
				background: rgba(27, 35, 55, 0.9);
				color: #dfe9ff;
				align-self: flex-start;
			}
			.chat-entry[data-role="user"] .chat-bubble {
				background: linear-gradient(135deg, rgba(80, 160, 255, 0.9), rgba(114, 92, 249, 0.95));
				color: #06101f;
				align-self: flex-end;
			}
			.chat-meta {
				font-size: 0.75rem;
				color: rgba(194, 205, 229, 0.7);
			}
			form {
				display: grid;
				grid-template-columns: 1fr auto;
				gap: 0.75rem;
			}
			textarea {
				border-radius: 12px;
				border: 1px solid rgba(255, 255, 255, 0.08);
				background: rgba(7, 12, 21, 0.9);
				color: inherit;
				min-height: 80px;
				padding: 0.85rem;
				font-family: inherit;
			}
			button {
				border: none;
				border-radius: 12px;
				background: linear-gradient(135deg, #66ccff, #7b6dff);
				color: #02050a;
				font-weight: 600;
				font-size: 1rem;
				padding: 0 1.5rem;
				cursor: pointer;
				box-shadow: 0 12px 30px rgba(102, 204, 255, 0.35);
			}
			button:disabled {
				opacity: 0.6;
				cursor: progress;
			}
			.sr-only {
				position: absolute;
				width: 1px;
				height: 1px;
				padding: 0;
				margin: -1px;
				overflow: hidden;
				clip: rect(0, 0, 0, 0);
				border: 0;
			}
			@media (max-width: 800px) {
				form {
					grid-template-columns: 1fr;
				}
				.chat-bubble {
					max-width: 100%;
				}
			}

			@media (max-width: 640px) {
				header {
					padding: 1.75rem 1rem 0.75rem;
				}
				main {
					padding: 0 1rem 3rem;
				}
				section {
					padding: 1.25rem;
				}
				table,
				th,
				td {
					font-size: 0.9rem;
				}
			}
		</style>
	</head>
	<body>
		<header>
			<h1>Portfolio Monitor Assistant</h1>
			<p>Review your tracked holdings and converse with the assistant to add, adjust, or remove assets.</p>
			<nav>
				<a href="/">Overview</a>
				<a href="/manage" aria-current="page">Portfolio management</a>
			</nav>
		</header>
		<main>
			<section>
				<h2>Holdings</h2>
				<div style="overflow-x:auto;">
					<table>
						<thead>
							<tr>
								<th>Label</th>
								<th>Type</th>
								<th>Quantity</th>
								<th>Price</th>
								<th>Value</th>
								<th>Status</th>
							</tr>
						</thead>
						<tbody id="asset-rows"></tbody>
					</table>
				</div>
			</section>

			<section id="chat-section">
				<h2>Chat Controls</h2>
				<div id="chat-log" aria-live="polite"></div>
				<form id="chat-form">
					<label for="chat-input" class="sr-only">Chat message</label>
					<textarea id="chat-input" placeholder="e.g. Add 2 ETH to the main wallet" required></textarea>
					<button type="submit">Send</button>
				</form>
			</section>
		</main>

		<script type="module">
			const state = {
				messages: [],
				currency: new Intl.NumberFormat("en-US", { style: "currency", currency: "USD" }),
				number: new Intl.NumberFormat("en-US", { maximumFractionDigits: 6 }),
				prices: null,
			};

			const assetRowsEl = document.getElementById("asset-rows");
			const chatLog = document.getElementById("chat-log");
			const chatForm = document.getElementById("chat-form");
			const chatInput = document.getElementById("chat-input");
			const chainSymbolMap = {
				bitcoin: "BTC",
				ethereum: "ETH",
				solana: "SOL",
			};

			init();

			async function init() {
				await loadPortfolio();
				appendChatEntry("assistant", "Hi! Tell me which blockchain addresses or gold/USD holdings you want to track.");
				state.messages.push({ role: "assistant", content: "Ready to help with your portfolio." });
			}

			async function loadPortfolio() {
				try {
					const summary = await fetchSummary();
					const prices = await ensurePrices();
					const assets = applyPrices(summary.assets ?? [], prices);
					renderAssetRows(assets);
				} catch (error) {
					console.error(error);
				}
			}

			chatForm.addEventListener("submit", async (event) => {
				event.preventDefault();
				const content = chatInput.value.trim();
				if (!content) {
					return;
				}

				appendChatEntry("user", content);
				state.messages.push({ role: "user", content });
				setFormDisabled(true);
				chatInput.value = "";

				const typingEntry = showTypingIndicator();
				try {
					const response = await fetch("/api/chat", {
						method: "POST",
						headers: { "content-type": "application/json" },
						body: JSON.stringify({ messages: state.messages }),
					});
					if (!response.ok) {
						throw new Error("Chat request failed");
					}
					const payload = await response.json();
					const reply = payload.reply ?? "Request processed.";
					removeTypingIndicator(typingEntry);
					appendChatEntry("assistant", formatAssistantReply(reply, payload.operations));
					state.messages.push({ role: "assistant", content: reply });
					if (payload.summary) {
						const prices = await ensurePrices();
						const assets = applyPrices(payload.summary.assets ?? [], prices);
						renderAssetRows(assets);
					}
				} catch (error) {
					removeTypingIndicator(typingEntry);
					appendChatEntry("assistant", "I hit an error handling that request. Try again.");
					console.error(error);
				} finally {
					setFormDisabled(false);
					chatInput.focus();
				}
			});

			async function fetchSummary() {
				const response = await fetch("/api/portfolio");
				if (!response.ok) {
					throw new Error("Failed to load portfolio");
				}
				return response.json();
			}

			async function ensurePrices() {
				if (state.prices) {
					return state.prices;
				}
				state.prices = await fetchPrices();
				return state.prices;
			}

			async function fetchPrices() {
				const basePrices = { BTC: 0, ETH: 0, SOL: 0, GOLD: 0, USD: 1 };
				const [cryptoResult, goldResult] = await Promise.allSettled([
					fetch("https://api.coingecko.com/api/v3/simple/price?ids=bitcoin,ethereum,solana&vs_currencies=usd"),
					fetch("https://data-asg.goldprice.org/dbXRates/USD"),
				]);

				if (cryptoResult.status === "fulfilled" && cryptoResult.value.ok) {
					const payload = await cryptoResult.value.json();
					basePrices.BTC = payload.bitcoin?.usd ?? 0;
					basePrices.ETH = payload.ethereum?.usd ?? 0;
					basePrices.SOL = payload.solana?.usd ?? 0;
				} else {
					console.warn("Failed to fetch crypto prices");
				}

				if (goldResult.status === "fulfilled" && goldResult.value.ok) {
					const payload = await goldResult.value.json();
					basePrices.GOLD = payload.items?.[0]?.xauPrice ?? payload.items?.[0]?.xauPriceGram24k ?? 0;
				} else {
					console.warn("Failed to fetch gold price");
				}

				return basePrices;
			}

			function applyPrices(assets, prices) {
				return assets.map((asset) => {
					const priced = { ...asset };
					const symbol =
						asset.category === "blockchain"
							? chainSymbolMap[asset.chain] ?? ""
							: asset.symbol ?? "";
					const usdPrice = symbol === "USD" ? 1 : prices[symbol] ?? 0;
					const quantity = Number.isFinite(priced.quantity) ? priced.quantity : 0;
					priced.usdPrice = usdPrice;
					priced.usdValue = quantity * usdPrice;
					if (priced.category === "physical" && symbol === "GOLD" && !usdPrice) {
						priced.status = "error";
						priced.message = "Price unavailable";
					}
					return priced;
				});
			}

			function renderAssetRows(assets) {
				assetRowsEl.innerHTML = "";
				for (const asset of assets) {
					const row = document.createElement("tr");
					row.innerHTML = [
						`<td>${asset.label}</td>`,
						`<td>${describeAsset(asset)}</td>`,
						`<td>${formatQuantity(asset)}</td>`,
						`<td>${formatPrice(asset.usdPrice)}</td>`,
						`<td>${state.currency.format(asset.usdValue)}</td>`,
						`<td class="status-${asset.status}">${asset.status === "ok" ? "OK" : asset.message ?? "Check"}</td>`,
					].join("");
					assetRowsEl.appendChild(row);
				}
			}

			function describeAsset(asset) {
				if (asset.category === "blockchain") {
					return `${asset.chain?.toUpperCase()}\n${asset.address}`;
				}
				return `${asset.symbol} holding`;
			}

			function formatQuantity(asset) {
				const quantity = state.number.format(asset.quantity);
				if (asset.category === "blockchain") {
					return `${quantity} ${asset.chain?.toUpperCase()}`;
				}
				return `${quantity} ${asset.symbol === "GOLD" ? "troy oz" : "USD"}`;
			}

			function formatPrice(price) {
				if (!Number.isFinite(price) || price <= 0) {
					return "--";
				}
				return state.currency.format(price);
			}

			function appendChatEntry(role, text) {
				const entry = document.createElement("div");
				entry.className = "chat-entry";
				entry.dataset.role = role;

				const meta = document.createElement("span");
				meta.className = "chat-meta";
				meta.textContent = role === "assistant" ? "Assistant" : "You";

				const bubble = document.createElement("div");
				bubble.className = "chat-bubble";
				bubble.textContent = text;

				entry.appendChild(meta);
				entry.appendChild(bubble);
				chatLog.appendChild(entry);
				chatLog.scrollTop = chatLog.scrollHeight;
			}

			function formatAssistantReply(reply, operations = []) {
				if (!operations.length) {
					return reply;
				}
				return [
					reply.trim(),
					"",
					"Operations:",
					...operations.map((operation) => `- [${operation.status}] ${operation.detail}`),
				].join("\n");
			}

			function setFormDisabled(disabled) {
				chatInput.disabled = disabled;
				chatForm.querySelector("button").disabled = disabled;
			}

			function showTypingIndicator() {
				const entry = document.createElement("div");
				entry.className = "chat-entry";
				entry.dataset.role = "assistant";

				const meta = document.createElement("span");
				meta.className = "chat-meta";
				meta.textContent = "Assistant";

				const bubble = document.createElement("div");
				bubble.className = "chat-bubble";
				bubble.textContent = "...";

				entry.appendChild(meta);
				entry.appendChild(bubble);
				chatLog.appendChild(entry);
				chatLog.scrollTop = chatLog.scrollHeight;
				return entry;
			}

			function removeTypingIndicator(entry) {
				if (entry && entry.parentElement === chatLog) {
					chatLog.removeChild(entry);
				}
			}
		</script>
	</body>
</html>
